Reflection on CS 300 Projects

Problem Solved in the Projects

In Project One, the objective was to conduct a runtime and memory analysis on various data structures to determine the most suitable choice for ABC University's advising system. Project Two required the development of a C++ program that could sort and print the university’s course catalog in alphanumeric order, focusing on maintainability and efficient data handling.

Approach and Importance of Data Structures

My approach was to assess each data structure's strengths and limitations—such as the Vector, Hash Table, and Binary Search Tree (BST)—by analyzing runtime complexity for insertion, search, and retrieval operations. Understanding these data structures is essential because selecting the right structure can optimize performance, especially when managing large datasets, and help ensure the scalability and efficiency of applications.

Overcoming Roadblocks

I encountered challenges with data structure selection due to performance trade-offs. For instance, the Hash Table was fast but prone to collision-related inefficiencies, while the BST provided predictable, balanced performance but required more complex balancing logic. I addressed these challenges by researching additional balancing methods and ultimately decided on the Binary Search Tree due to its consistent alphanumeric ordering and efficient in-order traversal for sorting.

Expanded Approach to Software Design and Development

Working on this project expanded my perspective on balancing performance and readability in software design. I became more aware of the implications each data structure choice has on memory usage and runtime efficiency, and I learned the importance of selecting a structure that best fits the specific needs of the program rather than simply optimizing for speed.

Evolution in Writing Maintainable, Readable, and Adaptable Code

This project reinforced the need for code clarity, modular design, and ample documentation. The use of meaningful function names, detailed comments, and well-organized code has made the program more maintainable and adaptable for future extensions. I now prioritize modularity and reusability in my code, which I recognize as crucial for long-term software development projects.
Summary 

Through these projects, I developed a more robust understanding of data structures and algorithmic efficiency. This experience has equipped me with a practical approach to problem-solving that considers both immediate and future maintainability needs, skills that will be valuable as I continue to grow in the field of software development.

